plugins {
    id 'java'
    id 'jacoco'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'org.springframework.boot' version '4.0.2' apply false
    id 'me.champeau.jmh' version '0.7.2' apply false
    id 'org.sonarqube' version '4.4.1.3373'
    id 'net.researchgate.release' version '3.0.2'
    id 'maven-publish'
    id 'signing'
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0'
}

// group, version, and description are managed in gradle.properties
description = 'curve'

// Nexus Publishing for Central Portal (New URL for Central Portal)
nexusPublishing {
    repositories {
        sonatype {
            nexusUrl.set(uri("https://ossrh-staging-api.central.sonatype.com/service/local/"))
            snapshotRepositoryUrl.set(uri("https://ossrh-staging-api.central.sonatype.com/content/repositories/snapshots/"))
            username.set(findProperty("ossrhUsername")?.toString() ?: System.getenv("OSSRH_USERNAME") ?: "")
            password.set(findProperty("ossrhPassword")?.toString() ?: System.getenv("OSSRH_PASSWORD") ?: "")
        }
    }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

allprojects {
    repositories {
        mavenCentral()
        maven {
            url = uri("https://packages.confluent.io/maven/")
        }
    }
}

// Modules to publish to Maven Central
def publishableProjects = ['core', 'spring', 'kafka', 'spring-boot-autoconfigure']

subprojects {

    apply plugin: 'java-library'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'jacoco'

    if (publishableProjects.contains(project.name)) {
        apply plugin: 'maven-publish'
        apply plugin: 'signing'
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    dependencyManagement {
        imports {
            mavenBom "org.springframework.boot:spring-boot-dependencies:4.0.2"
        }
    }

    dependencies {
        // Lombok
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'

        testCompileOnly 'org.projectlombok:lombok'
        testAnnotationProcessor 'org.projectlombok:lombok'

        // Test
        testImplementation 'org.junit.jupiter:junit-jupiter'
        testImplementation 'org.junit.platform:junit-platform-launcher'
        testImplementation 'org.assertj:assertj-core'
        testImplementation 'org.mockito:mockito-core'
        testImplementation 'org.mockito:mockito-junit-jupiter'
        testImplementation 'org.springframework:spring-test'
    }

    test {
        useJUnitPlatform()
        finalizedBy jacocoTestReport
    }

    jacoco {
        toolVersion = "0.8.12"
    }

    jacocoTestReport {
        dependsOn test
        reports {
            xml.required = true
            html.required = true
            csv.required = false
        }

        afterEvaluate {
            classDirectories.setFrom(files(classDirectories.files.collect {
                fileTree(dir: it, exclude: [
                        '**/config/**',
                        '**/configuration/**',
                        '**/autoconfigure/**',
                        '**/*Application.*',
                        '**/*Config.*',
                        '**/*Properties.*'
                ])
            }))
        }
    }

    jacocoTestCoverageVerification {
        dependsOn jacocoTestReport
        violationRules {
            rule {
                enabled = true
                element = 'CLASS'
                limit {
                    counter = 'LINE'
                    value = 'COVEREDRATIO'
                    minimum = 0.70
                }
                excludes = [
                        '*.config.*',
                        '*.configuration.*',
                        '*.autoconfigure.*',
                        '*Application',
                        '*Config',
                        '*Properties',
                        // Kafka
                        '*KafkaEventProducer',
                        '*BackupStrategy*', // Exclude Backup Strategies from coverage check
                        // Spring Serializers (verified through integration tests)
                        '*EventSerializer',
                        // Spring Context Providers (requires Spring integration)
                        '*ContextProvider',
                        '*.context.*ContextDecorator',
                        '*ContextAwareTaskDecorator',
                        // Spring Outbox (requires database integration)
                        '*OutboxEventPublisher*',
                        '*OutboxEventSaver',
                        '*OutboxEventJpaEntity',
                        '*OutboxEventRepository*',
                        '*JdbcOutboxEventRepository*',
                        '*JpaOutboxEventRepositoryAdapter',
                        // Spring PII Jackson (requires Jackson integration)
                        '*PiiModule',
                        '*PiiPropertyWriter',
                        '*PiiBeanSerializerModifier',
                        '*PiiProcessor*',
                        // Spring Publisher (abstract class)
                        '*AbstractEventPublisher',
                        // Test utilities
                        '*MockEventProducer',
                        // Validators (requires SPEL integration)
                        '*SpelExpressionValidator',
                        // Default types
                        '*DefaultEventType',
                        // Metrics (requires Micrometer integration)
                        '*MicrometerCurveMetricsCollector'
                ]
            }
        }
    }

    tasks.withType(Javadoc).configureEach {
        def opts = options as StandardJavadocDocletOptions

        opts.encoding = 'UTF-8'
        opts.charSet = 'UTF-8'
        opts.docEncoding = 'UTF-8'

        opts.addStringOption('Xdoclint:none', '-quiet')

        if (JavaVersion.current().isJava9Compatible()) {
            opts.addBooleanOption('html5', true)
        }

        failOnError = false
    }

    tasks.register('javadocJar', Jar) {
        dependsOn javadoc
        archiveClassifier.set('javadoc')
        from javadoc
    }

    tasks.register('sourcesJar', Jar) {
        archiveClassifier.set('sources')
        from sourceSets.main.allSource
    }

    artifacts {
        archives javadocJar
        archives sourcesJar
    }

    if (publishableProjects.contains(project.name)) {
        publishing {
            publications {
                mavenJava(MavenPublication) {
                    from components.java

                    artifactId = project.name == 'spring-boot-autoconfigure' ? 'curve' : "curve-${project.name}"

                    artifact sourcesJar
                    artifact javadocJar

                    pom {
                        name = project.name == 'spring-boot-autoconfigure' ? 'curve' : "curve-${project.name}"
                        description = 'Curve - Declarative Event Publishing Library for Spring Boot Microservices'
                        url = 'https://github.com/closeup1202/curve'

                        licenses {
                            license {
                                name = 'MIT License'
                                url = 'https://opensource.org/licenses/MIT'
                            }
                        }

                        developers {
                            developer {
                                id = 'closeup1202'
                                name = 'closeup1202'
                                email = 'closeup1202@gmail.com'
                            }
                        }

                        scm {
                            connection = 'scm:git:git://github.com/closeup1202/curve.git'
                            developerConnection = 'scm:git:ssh://github.com:closeup1202/curve.git'
                            url = 'https://github.com/closeup1202/curve'
                        }
                    }
                }
            }

            // Repository is managed by nexusPublishing plugin
        }

        signing {
            required { !version.endsWith('SNAPSHOT') }
            useGpgCmd()
            sign publishing.publications.mavenJava
        }
    }
}

// SonarQube Configuration
sonar {
    properties {
        property "sonar.projectName", "Curve"
        property "sonar.projectKey", "curve"
        property "sonar.host.url", System.getenv("SONAR_HOST_URL") ?: "https://sonarcloud.io"
        property "sonar.organization", System.getenv("SONAR_ORGANIZATION") ?: ""
        property "sonar.sourceEncoding", "UTF-8"
        property "sonar.java.source", "17"
        property "sonar.coverage.jacoco.xmlReportPaths", [
            "${rootProject.projectDir}/core/build/reports/jacoco/test/jacocoTestReport.xml",
            "${rootProject.projectDir}/spring/build/reports/jacoco/test/jacocoTestReport.xml",
            "${rootProject.projectDir}/kafka/build/reports/jacoco/test/jacocoTestReport.xml",
            "${rootProject.projectDir}/spring-boot-autoconfigure/build/reports/jacoco/test/jacocoTestReport.xml"
        ].join(',')
        property "sonar.exclusions", [
            "**/*Application.java",
            "**/*Config.java",
            "**/*Configuration.java",
            "**/*Properties.java",
            "**/autoconfigure/**"
        ].join(',')
    }
}

// Release Plugin Configuration
release {
    failOnCommitNeeded = false
    failOnPublishNeeded = false
    failOnSnapshotDependencies = false
    failOnUnversionedFiles = false
    failOnUpdateNeeded = false
    revertOnFail = true
    preCommitText = ''
    preTagCommitMessage = '[Gradle Release Plugin] - pre tag commit: '
    tagCommitMessage = '[Gradle Release Plugin] - creating tag: '
    newVersionCommitMessage = '[Gradle Release Plugin] - new version commit: '
    tagTemplate = 'v${version}'
    versionPropertyFile = 'gradle.properties'
    buildTasks = ['build']

    git {
        requireBranch.set('main')
        pushToRemote.set('origin')
    }
}
